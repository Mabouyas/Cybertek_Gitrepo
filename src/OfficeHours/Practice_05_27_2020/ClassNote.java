package OfficeHours.Practice_05_27_2020;

public class ClassNote {
	/*
    05/27/2020
Practice Topics: Method overloading & Overriding
			     OOP Summary (Encapsulation & Inheritance)
office hour: 2pm ~ 4pm
Package Name: Practice_05_27_2020
overloading: same method name, different parameter (MUST)
             return type does't matter
             access modifier does not matter
             any method can be overloaded
overriding: same name & same parameter
		    access modifiers need to be same or more visible
		    return-type MUST be same
		    ONLy the instance method (visible) can be overriding
	pre-condition: MUST take place in subclass (child)
	@Override: checks if method is being overriding
why we need overriding:
	to implement different function/implementation to the method
visibility:
	public > protected > default > private
example1:
		car:
			start(): push button
		BMW:
			start(): push the start button
		Toyota:
			start(): Insert key
Ex2:
		shape:
			Area():
		Circle:
			Area(): PI * R
		Triangle:
			Area(): Base * Height * 1/2
		same method name & same parameter, but different implementation
Encapsulation: hiding the data by giving private access modifier
				other sources can only access to it through public getter/setter
				getter (READ ONLY): returns the private data
				setter(Write ONLY): assigning the argument to the private data
Inheritance: building relationships between class
		     super & sub relation
		     super class: cannot inherit anything from sub class
		     sub class: inherits the methods and variables (Visible) from super class
		     advantages:
		     	reusable
		     	readable
		     	organized
		     	easy to memorize
		     	easy to maintain
			TestBase:
				setUp(): login ...
			Test1:
			Test2:
			....
tomorrow's topic: Exceptions
				  Abstraction
				  Polymorphism
				  Collection
				  Maps
     */
	
}
